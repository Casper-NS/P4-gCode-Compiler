Package GGCodeParser;

Helpers
  all = [0 .. 127];
  not_curleys = [all - ['{' + '}']];
  tab   = 9;
  cr    = 13;
  lf    = 10;
  digit = ['0'..'9'];
  lowercase = ['a'..'z'];
  uppercase = ['A'..'Z'];
  letter  = lowercase | uppercase;
  idletter = letter | '_';
  idchar  = letter | '_' | digit;
  xyz = 'x' | 'y' | 'z' | 'X' | 'Y' | 'Z';
  star = '*';
  not_star = [all - star];
  not_star_slash = [not_star - '/'];
  eol_char = cr | lf | cr lf;
  not_eol_char = [all - [cr + lf]];

Tokens
  eol   = cr | lf | cr lf;
  blank = ' ' | tab;
  assignment_op = '=';
  multiplication_op  = '*';
  modulo_op  = '%';
  division_op = '/';
  plus_op  = '+';
  minus_op = '-';
  equal = '==';
  less_than = '<';
  less_than_or_equal = '<=';
  greater_than = '>';
  greater_than_or_equal = '>=';
  not = '!';
  not_equal = '!=';
  l_par = '(';
  r_par = ')';
  l_cur = '{';
  r_cur = '}';
  comma = ',';
  vector = 'vector';
  int = 'int';
  const = 'const';
  float = 'float';
  bool = 'bool';
  void = 'void';
  bool_value = 'true' | 'false';
  if = 'if';
  else = 'else';
  repeat = 'repeat';
  while = 'while';
  return = 'return';
  build = 'build';
  walk = 'walk';
  gcode = 'GCODE';
  and = '&&';
  or = '||';
  number  = '0'| [digit-'0'] digit* | digit* '.' digit*;
  identifier    = idletter idchar* | idletter idchar* '.' xyz;
  all_chars_except_curly = not_curleys;
  multiline_comment = '/*' not_star * star + ( not_star_slash not_star * star+) * '/' eol_char;
  singleline_comment = '//' not_eol_char* eol_char;

Ignored Tokens
  blank, multiline_comment, singleline_comment;

Productions
cst_program = cst_declaration_list;

cst_declaration_list =
        {list}cst_declaration eol+ cst_declaration_list | 
        cst_declaration eol*;

cst_declaration = 
        {variable}cst_variable_declaration | 
        {function}cst_function_declaration;

cst_variable_declaration =
        {initialised}const? cst_types identifier assignment_op cst_expression |
        cst_uninitialised_variable;

cst_uninitialised_variable =
        const? cst_types identifier;

cst_types = 
        {integer}int | 
        {floatingpoint}float | 
        {bool}bool |
        {vector}vector;

cst_vector_values = l_par [a]:cst_expression [q]:comma [b]:cst_expression [w]:comma [c]:cst_expression r_par;

cst_function_declaration =
        {notvoid} cst_types identifier l_par cst_formal_param_list? r_par eol? cst_block |
        {void} void         identifier l_par cst_formal_param_list? r_par eol? cst_block;

cst_formal_param_list = 
        {list}cst_uninitialised_variable comma cst_formal_param_list | 
              cst_uninitialised_variable;

cst_block = l_cur eol cst_statement_list r_cur;

cst_statement_list = 
        {list}cst_statement eol+ cst_statement_list | 
        cst_statement eol+;

cst_statement = 
        {decl}cst_variable_declaration | 
        {if}cst_if_statement | 
        {repeat}cst_repeat_statement | 
        {while}cst_while_statement | 
        {gcode}cst_gcode_literal | 
        {assignment}cst_assignments | 
        {function}cst_function_call |
        {return}return cst_expression |
        {build} build eol? cst_block |
        {walk} walk eol? cst_block;

cst_if_statement = 
        {noelse}  if l_par cst_expression r_par eol? cst_block | 
        {withelse}if l_par cst_expression r_par eol? [a]:cst_block else [b]:cst_block;

cst_repeat_statement = repeat l_par cst_expression r_par eol? cst_block;

cst_while_statement = while l_par cst_expression r_par eol? cst_block;

cst_gcode_literal = gcode l_cur all_chars_except_curly r_cur;

cst_assignments = 
        {assign}identifier assignment_op cst_expression |
        {assign_plus}identifier plus_op assignment_op cst_expression |
        {assign_minus}identifier minus_op assignment_op cst_expression |
        {assign_mult}identifier multiplication_op assignment_op cst_expression |
        {assign_division}identifier division_op assignment_op cst_expression |
        {assign_mod}identifier modulo_op assignment_op cst_expression;

cst_function_call = identifier l_par cst_actual_param_list? r_par;

cst_actual_param_list =
        {list}cst_expression comma cst_actual_param_list | 
        cst_expression;

cst_expression =
        {and} cst_logic_or_exp and cst_expression |
        cst_logic_or_exp;

cst_logic_or_exp =
        {or} cst_bool_exp or cst_logic_or_exp |
        cst_bool_exp;

cst_bool_exp =
        {not}not cst_bool_exp |
        {equal}[a]:cst_associative_exp equal                 [b]:cst_associative_exp |
        {le}   [a]:cst_associative_exp less_than             [b]:cst_associative_exp |
        {leq}  [a]:cst_associative_exp less_than_or_equal    [b]:cst_associative_exp |
        {ge}   [a]:cst_associative_exp greater_than          [b]:cst_associative_exp | 
        {geq}  [a]:cst_associative_exp greater_than_or_equal [b]:cst_associative_exp |
        {neq}  [a]:cst_associative_exp not_equal             [b]:cst_associative_exp |
        cst_associative_exp;

cst_associative_exp = 
        {plus} cst_not_associative_exp plus_op  cst_associative_exp |
        {minus}cst_not_associative_exp minus_op cst_associative_exp |
        cst_not_associative_exp;

cst_not_associative_exp =
        {mult}    cst_not_associative_exp multiplication_op cst_leaf_exp |
        {division}cst_not_associative_exp division_op       cst_leaf_exp |
        {modulo}  cst_not_associative_exp modulo_op         cst_leaf_exp |
        cst_leaf_exp;

cst_leaf_exp =
        {paren}l_par cst_expression r_par |
        {number}number |
        {bool}bool_value |
        {id}identifier |
        {func_call}cst_function_call |
        {vector}cst_vector_values;