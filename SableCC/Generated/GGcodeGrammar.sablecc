Package GGCodeParser;

Helpers
  all = [0 .. 127];
  l_curley = '{';
  r_curley = '}';
  not_curleys = [all - [l_curley + r_curley]];
  tab   = 9;
  cr    = 13;
  lf    = 10;
  digit = ['0'..'9'];
  lowercase = ['a'..'z'];
  uppercase = ['A'..'Z'];
  letter  = lowercase | uppercase;
  idletter = letter | '_';
  idchar  = letter | '_' | digit;
  dot = '.';

Tokens
  main = 'main';
  eol   = cr | lf | cr lf;
  blank = ' ' | tab;
  assignment_op = '=';
  multiplication_op  = '*';
  modulo_op  = '%';
  division_op = '/';
  plus_op  = '+';
  minus_op = '-';
  equal = '==';
  less_than = '<';
  less_than_or_equal = '<=';
  greater_than = '>';
  greater_than_or_equal = '>=';
  not = '!';
  l_par = '(';
  r_par = ')';
  l_cur = '{';
  r_cur = '}';
  comma = ',';
  vector = 'vector';
  int = 'int';
  const = 'const';
  float = 'float';
  bool = 'bool';
  void = 'void';
  bool_value = 'true' | 'false';
  if = 'if';
  else = 'else';
  repeat = 'repeat';
  while = 'while';
  return = 'return';
  gcode = 'GCODE';
  and = '&&';
  or = '||';
  number  = '0'| [digit-'0'] digit* | digit* dot digit*;
  identifier    = idletter idchar*;
  all_chars_except_curly = not_curleys;

Ignored Tokens
  blank;

Productions
cst_program = [a]:cst_declaration_list;

cst_main_function_declaration =
        main l_par r_par eol? cst_function_body;

cst_declaration_list =
        {recursive}cst_declaration eol+ cst_declaration_list | 
        cst_declaration;

cst_declaration = 
        {variable}cst_variable_declaration | 
        {function}cst_function_declaration |
        {main}cst_main_function_declaration;

cst_variable_declaration =
        {simple_initial}const? cst_simple_types identifier assignment_op cst_expression |
        {simple_uninitial}const? cst_simple_types identifier |
        {vector}cst_vector_declaration;

cst_vector_declaration = 
        {initial}const? vector identifier assignment_op cst_vector_values |
        const? cst_vector_values identifier;

cst_all_types = 
        {simple}cst_simple_types | 
        vector;

cst_simple_types =
        {integer}int | 
        {floatingpoint}float | 
        {bool}bool;

cst_vector_values = l_par [a]:cst_expression [q]:comma [b]:cst_expression [w]:comma [c]:cst_expression r_par;

cst_function_declaration =
        {notvoid}cst_all_types identifier l_par cst_formal_param_list? r_par eol cst_function_body |
        void identifier l_par cst_formal_param_list? r_par eol cst_function_body;

cst_formal_param_list = 
        {recursive}cst_formal_param comma cst_formal_param_list | 
        cst_formal_param;

cst_formal_param = cst_all_types identifier;

cst_function_body = cst_block;

cst_block = l_cur eol cst_statement_list r_cur;

cst_statement_list = 
        {recursive}cst_statement eol cst_statement_list | 
        cst_statement eol;

cst_statement = 
        {decl}cst_variable_declaration | 
        {if}cst_if_statement | 
        {repeat}cst_repeat_statement | 
        {while}cst_while_statement | 
        {gcode}cst_gcode_literal | 
        {assignment}cst_assignments | 
        {function}cst_function_call |
        {return}cst_return;

cst_if_statement = 
        {noelse}if l_par cst_expression r_par eol cst_block | 
        {withelse}if l_par cst_expression r_par eol [a]:cst_block else [b]:cst_block;

cst_repeat_statement = repeat l_par cst_expression r_par eol cst_block;

cst_while_statement = while l_par cst_expression r_par eol cst_block;

cst_gcode_literal = gcode l_cur all_chars_except_curly r_cur;

cst_assignments = 
        {assign}identifier assignment_op cst_expression |
        {assign_plus}identifier plus_op assignment_op cst_expression |
        {assign_minus}identifier minus_op assignment_op cst_expression |
        {assign_mult}identifier multiplication_op assignment_op cst_expression |
        {assign_division}identifier division_op assignment_op cst_expression |
        {assign_mod}identifier modulo_op assignment_op cst_expression;

cst_function_call = identifier l_par cst_actual_param_list? r_par;

cst_return = return cst_expression;

cst_actual_param_list =
        {recursive}cst_expression comma cst_actual_param_list | 
        cst_expression;

cst_expression =
        {not}not cst_expression |
        cst_lowest_exp;

cst_lowest_exp =
        {equal}cst_low_exp [c]:equal [d]:equal cst_expression |
        {le}cst_low_exp less_than cst_expression |
        {leq}cst_low_exp less_than_or_equal cst_expression |
        {ge}cst_low_exp greater_than cst_expression | 
        {geq}cst_low_exp greater_than_or_equal cst_expression |
        {neq}cst_low_exp not equal cst_expression |
        cst_low_exp;

cst_low_exp = 
        {plus}cst_medium_exp plus_op cst_low_exp |
        {minus}cst_medium_exp minus_op cst_low_exp |
        cst_medium_exp;

cst_medium_exp =
        {mult}cst_medium_exp multiplication_op cst_high_exp |
        {division}cst_medium_exp division_op cst_high_exp |
        {modulo}cst_medium_exp modulo_op cst_high_exp |
        cst_high_exp;

cst_high_exp =
        {number}number |
        {bool}bool_value |
        {id}identifier |
        {func_call}cst_function_call |
        {vector}cst_vector_values |
        cst_highest_exp;

cst_highest_exp =
        {paren}l_par cst_expression r_par;